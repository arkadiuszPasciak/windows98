import { Meta, Title } from "@storybook/addon-docs/blocks";

<Meta title="Workspaces/Micro Services/Guide/Architecture" />

<Title>ğŸ—ï¸ Service Architecture</Title>

Understanding the architectural patterns and design principles behind Windows98 micro-services.

## Architecture Overview

The Windows98 micro-services architecture is built on principles of modularity, separation of concerns, and maintainable design. Each service is designed to be independent, focused, and easily integrable.

## Core Architecture Patterns

### Service Layer Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        Domain Layer             â”‚ â† Business Logic
â”‚  â€¢ Domain Services              â”‚
â”‚  â€¢ Domain Contracts             â”‚ 
â”‚  â€¢ Business Rules               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚         Data Layer              â”‚ â† External Integrations
â”‚  â€¢ Repositories                 â”‚
â”‚  â€¢ External API Adapters        â”‚
â”‚  â€¢ Browser API Wrappers         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### Domain Layer (`src/domain/`)
- **Business Logic**: Core service functionality and business rules
- **Domain Contracts**: Interface definitions that establish service contracts
- **Domain Services**: Implementation of business logic using repository abstractions
- **State Management**: Internal service state handling and validation
- **Domain Models**: Business entities and value objects

**Structure:**
```
domain/
â”œâ”€â”€ contracts/          # Interface definitions
â”‚   â”œâ”€â”€ domain.contract.ts
â”‚   â”œâ”€â”€ repository.contract.ts
â”‚   â””â”€â”€ index.ts
â””â”€â”€ domains/           # Business logic implementations
    â”œâ”€â”€ storage.domain.ts
    â”œâ”€â”€ local-storage.domain.ts
    â””â”€â”€ index.ts
```

#### Data Layer (`src/data/`)
- **Repository Pattern**: Concrete implementations of data access contracts
- **External Integration**: Interfaces with browser APIs, external services
- **Data Transformation**: Converts between internal and external data formats
- **Protocol Handling**: Manages different communication protocols
- **Fallback Mechanisms**: Provides alternatives when external services fail

**Structure:**
```
data/
â””â”€â”€ repositories/      # External data access implementations
    â”œâ”€â”€ local-storage.repository.ts
    â”œâ”€â”€ session-storage.repository.ts
    â””â”€â”€ index.ts
```

#### External Dependencies Layer
- **Browser APIs**: localStorage, sessionStorage, fetch, etc.
- **Third-party Services**: External APIs and services
- **System Resources**: File system, network, hardware APIs

## Service Communication Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        Micro Frontend           â”‚    â”‚        Micro Service            â”‚    â”‚ External APIs   â”‚
â”‚                                 â”‚    â”‚                                 â”‚    â”‚                 â”‚
â”‚  Domain Layer:                  â”‚    â”‚  Domain Layer:                  â”‚    â”‚  â€¢ Browser APIs â”‚
â”‚  â€¢ Components                   â”‚â”€â”€â”€â”€â”‚  â€¢ Domain Services              â”‚â”€â”€â”€â”€â”‚  â€¢ Storage APIs â”‚
â”‚  â€¢ Views                        â”‚    â”‚  â€¢ Domain Contracts             â”‚    â”‚  â€¢ Network APIs â”‚
â”‚  â€¢ Business Logic               â”‚    â”‚  â€¢ Business Rules               â”‚    â”‚  â€¢ File APIs    â”‚
â”‚                                 â”‚    â”‚                                 â”‚    â”‚                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Communication Flow

#### 1. Micro Frontend â†’ Micro Service
```tsx
// Micro Frontend (Domain Layer)
class ThemeComponent {
  constructor(private themeService: MSTheme) {}
  
  async changeTheme(theme: string) {
    // Business logic in micro frontend
    if (this.isValidTheme(theme)) {
      await this.themeService.setTheme(theme) // Call to micro service domain
    }
  }
}

// Micro Service (Domain Layer) 
class MSTheme extends StorageDomain {
  async setTheme(theme: string) {
    // Business logic in micro service
    this.validateTheme(theme)
    this.set('current-theme', theme) // Uses repository via parent class
  }
}
```

#### 2. Micro Service â†’ External APIs
```tsx
// Micro Service (Data Layer)
class LocalStorageRepository implements StorageRepositoryContract {
  setItem(key: string, value: string) {
    // Direct connection to browser API
    window.localStorage.setItem(key, value)
  }
}
```

#### 3. Event-Driven Communication
```tsx
// Micro Frontend (Data Layer) - Event listener
class ThemeEventAdapter {
  constructor(private eventBus: MSEventBus) {
    this.eventBus.on('theme-changed', this.handleThemeChange)
  }
}

// Micro Service (Domain Layer) - Event emission
class MSTheme {
  setTheme(theme: string) {
    this.repository.setItem('theme', theme)
    this.eventBus.emit('theme-changed', theme) // Notify other components
  }
}
```

### Practical Architecture Example: MSStorage

Here's how the data/domain pattern works in practice using the MSStorage service:

#### Domain Layer (Business Logic)

```tsx
// domain/contracts/domain.contract.ts
export interface StorageDomainContract<StorageKeys> {
  set<Key extends keyof StorageKeys>(key: Key, value: StorageKeys[Key]): void
  get<Key extends keyof StorageKeys>(key: Key): Maybe<StorageKeys[Key]>
  exists<Key extends keyof StorageKeys>(key: Key): boolean
  remove<Key extends keyof StorageKeys>(key: Key): void
}

// domain/contracts/repository.contract.ts
export interface StorageRepositoryStrategyContract<StorageKeys> {
  getItem<Key extends keyof StorageKeys>(key: Key): Maybe<StorageKeys[Key]>
  setItem<Key extends keyof StorageKeys>(key: Key, value: StorageKeys[Key]): void
  removeItem<Key extends keyof StorageKeys>(key: Key): void
  clear(): void
}

// domain/domains/storage.domain.ts
export class StorageDomain<StorageKeys> implements StorageDomainContract<StorageKeys> {
  constructor(
    private storageRepository: StorageRepositoryStrategyContract<StorageKeys>
  ) {}

  public set<Key extends keyof StorageKeys>(key: Key, value: StorageKeys[Key]): void {
    this.storageRepository.setItem(key, value)
  }

  public get<Key extends keyof StorageKeys>(key: Key): Maybe<StorageKeys[Key]> {
    return this.storageRepository.getItem(key)
  }

  public exists<Key extends keyof StorageKeys>(key: Key): boolean {
    const item = this.get(key)
    return !!item?.toString().length
  }

  public remove<Key extends keyof StorageKeys>(key: Key): void {
    this.storageRepository.removeItem(key)
  }
}

// domain/domains/local-storage.domain.ts
export class MSLocalStorage<StorageKeys> extends StorageDomain<StorageKeys> {
  constructor() {
    super(new LocalStorageRepository<StorageKeys>())
  }
}
```

#### Data Layer (External Connections)

```tsx
// data/repositories/local-storage.repository.ts
export class LocalStorageRepository<StorageKeys> 
  implements StorageRepositoryStrategyContract<StorageKeys> {
  
  public getItem<Key extends keyof StorageKeys>(key: Key): Maybe<StorageKeys[Key]> {
    return window.localStorage.getItem(key as string) as StorageKeys[Key]
  }

  public setItem<Key extends keyof StorageKeys>(key: Key, value: StorageKeys[Key]): void {
    window.localStorage.setItem(key as string, value as string)
  }

  public removeItem<Key extends keyof StorageKeys>(key: Key): void {
    window.localStorage.removeItem(key as string)
  }

  public clear(): void {
    window.localStorage.clear()
  }
}

// data/repositories/session-storage.repository.ts
export class SessionStorageRepository<StorageKeys> 
  implements StorageRepositoryStrategyContract<StorageKeys> {
  
  public getItem<Key extends keyof StorageKeys>(key: Key): Maybe<StorageKeys[Key]> {
    return window.sessionStorage.getItem(key as string) as StorageKeys[Key]
  }

  public setItem<Key extends keyof StorageKeys>(key: Key, value: StorageKeys[Key]): void {
    window.sessionStorage.setItem(key as string, value as string)
  }

  public removeItem<Key extends keyof StorageKeys>(key: Key): void {
    window.sessionStorage.removeItem(key as string)
  }

  public clear(): void {
    window.sessionStorage.clear()
  }
}
```

#### Public API Layer

```tsx
// index.ts
export { MSLocalStorage, MSSessionStorage } from "./domain/domains"
```

### Architecture Benefits

This data/domain separation provides several key advantages:

1. **Separation of Concerns**: Business logic is separated from external dependencies
2. **Testability**: Domain logic can be tested independently of browser APIs
3. **Flexibility**: Easy to switch storage strategies without changing business logic
4. **Type Safety**: Strong typing throughout all layers
5. **Strategy Pattern**: Repository implementations can be swapped based on context

### Usage Example

```tsx
// Consumer code doesn't know about repositories or browser APIs
interface UserPreferences {
  theme: string
  language: string
  notifications: boolean
}

const userStorage = new MSLocalStorage<UserPreferences>()

// Business logic methods
userStorage.set('theme', 'dark')
const theme = userStorage.get('theme')
const hasTheme = userStorage.exists('theme')
userStorage.remove('notifications')
```

#### 1. Direct Service Access
```tsx
// Direct method calls for synchronous operations
const theme = themeService.getCurrentTheme()
await storageService.setItem('key', value)
```

#### 2. Event-Driven Communication
```tsx
// Asynchronous, decoupled communication
eventBus.emit('theme-changed', newTheme)
eventBus.on('user-action', handleUserAction)
```

#### 3. Observer Pattern
```tsx
// Service state change notifications
themeService.subscribe(theme => updateUI(theme))
```

#### 4. Dependency Injection
```tsx
// Service composition and testing
class MyService {
  constructor(
    private storage: MSStorage,
    private eventBus: MSEventBus
  ) {}
}
```

## Service Design Principles

### 1. Data/Domain Separation
Services are organized into two distinct layers:

```tsx
// âœ… Good - Clear separation between data and domain
// Data layer handles external connections
class LocalStorageRepository implements StorageRepositoryContract {
  getItem(key: string) { 
    return window.localStorage.getItem(key) // Browser API access
  }
}

// Domain layer handles business logic
class StorageDomain {
  constructor(private repository: StorageRepositoryContract) {}
  
  exists(key: string): boolean {
    const item = this.repository.getItem(key)
    return !!item?.toString().length // Business rule
  }
}

// âŒ Bad - Mixed concerns
class MSStorage {
  exists(key: string): boolean {
    // Business logic mixed with browser API
    const item = window.localStorage.getItem(key)
    return !!item?.toString().length
  }
}
```

### 2. Repository Pattern Implementation
External dependencies are abstracted through repository contracts:

```tsx
// âœ… Good - Repository abstraction
interface StorageRepositoryContract {
  getItem(key: string): string | null
  setItem(key: string, value: string): void
}

class StorageDomain {
  constructor(private repository: StorageRepositoryContract) {}
  // Domain logic works with any repository implementation
}

// âŒ Bad - Direct dependency on external API
class StorageDomain {
  get(key: string) {
    return window.localStorage.getItem(key) // Tightly coupled
  }
}
```

### 3. Single Responsibility Principle (SRP)
Each layer and class has one well-defined responsibility:

```tsx
// âœ… Good - Focused responsibilities
class StorageDomain {
  set(key: string, value: string) { /* business logic only */ }
  get(key: string) { /* business logic only */ }
}

class LocalStorageRepository {
  getItem(key: string) { /* localStorage API only */ }
  setItem(key: string, value: string) { /* localStorage API only */ }
}

// âŒ Bad - Mixed responsibilities
class MSStorage {
  set(key: string, value: string) { /* business + API logic */ }
  validateUser(user: User) { /* unrelated validation logic */ }
}
```

### 4. Interface Segregation
Services provide focused, minimal interfaces through contracts:

```tsx
// âœ… Good - Specific, focused contracts
interface StorageDomainContract<T> {
  get<K extends keyof T>(key: K): Maybe<T[K]>
  set<K extends keyof T>(key: K, value: T[K]): void
  exists<K extends keyof T>(key: K): boolean
  remove<K extends keyof T>(key: K): void
}

interface StorageRepositoryContract<T> {
  getItem<K extends keyof T>(key: K): Maybe<T[K]>
  setItem<K extends keyof T>(key: K, value: T[K]): void
  removeItem<K extends keyof T>(key: K): void
  clear(): void
}

// âŒ Bad - Monolithic interface
interface StorageService {
  // Too many responsibilities in one interface
  get(key: string): any
  set(key: string, value: any): void
  validateData(data: any): boolean
  sendToServer(data: any): Promise<void>
  logActivity(action: string): void
}
```

### 5. Dependency Inversion
Domain layer depends on abstractions (contracts), not concrete implementations:

```tsx
// âœ… Good - Depends on abstraction
class StorageDomain {
  constructor(private repository: StorageRepositoryContract) {}
  // Works with any repository implementation
}

// âŒ Bad - Depends on concrete implementation
class StorageDomain {
  constructor(private localStorage: LocalStorageRepository) {}
  // Tightly coupled to specific repository
}
```

### 6. Strategy Pattern for Data Access
Different storage strategies can be used without changing domain logic:

```tsx
// âœ… Good - Strategy pattern implementation
const localStorageStrategy = new LocalStorageRepository()
const sessionStorageStrategy = new SessionStorageRepository()
const memoryStorageStrategy = new MemoryStorageRepository()

// Same domain logic, different storage strategies
const localStorage = new StorageDomain(localStorageStrategy)
const sessionStorage = new StorageDomain(sessionStorageStrategy)
const memoryStorage = new StorageDomain(memoryStorageStrategy)

// Usage is identical regardless of strategy
localStorage.set('theme', 'dark')
sessionStorage.set('token', 'abc123')
memoryStorage.set('cache', data)
```
